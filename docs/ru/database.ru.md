# Схема базы данных

**Схема:**

![Схема базы данных](../schema.png)
1.  **Почему четыре таблицы?**
    Я разделил данные на четыре таблицы для поддержания определенного уровня нормализации. Хотя в примере JSON были пересекающиеся поля (например, `transaction` в `payments` и `order_uid` в `orders`), я не исходил из того, что они всегда одинаковы, поэтому я рассматривал их как независимые поля, а не объединял в одно

2.  **Зачем используются суррогатные ключи?**
    Я подумал, что если в базе данных хранится, например, 10 миллионов записей, соединения (joins) с использованием строк (`TEXT`) в качестве основных ключей могут привести к проблемам с производительностью. Использование суррогатных/подсадных целочисленных ID уменьшает объем хранения и ускоряет соединения, так как процессору эффективнее сравнивать целые числа, а не строки.
    _Альтернатива_: можно было бы использовать естественные ключи (`order_uid`, `transaction`) непосредственно в качестве первичных ключей. Мы бы избавились от 'лишних' столбцов, но получили бы более медленные соединения и большие накладные расходы на хранение в долгосрочной перспективе (всё-таки строка сильно больше по размеру чем инт).

3.  **Почему везде ограничения NOT NULL?**
    Это гарантирует, что база данных будет отклонять некорректные/неполные данные, если в логике приложения на Go произойдет сбой. Это своего рода страховка.

4. **Зачем таймстампы?**    
    Это используется только кэшем для предзагрузки, на случай если БД уже имеет заказы или сервис-потребитель упал.

### Другая документация:
* [Принцип работы потребителя](consumer.ru.md)
* [Реализация кэша](cache.ru.md)
* [Валидация JSON](validation.ru.md)
* [Ошибки, метрики и проверки состояния БД](misc.ru.md)

### Вернуться к [Основному README](../../README.ru.md)